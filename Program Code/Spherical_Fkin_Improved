import numpy as np
import sympy as sp

# Link lengths in mm
a1 = float(input("a1 = "))
a2 = float(input("a2 = "))
a3 = float(input("a3 = "))

# Joint variables: in mm if d, in degrees if theta
T1 = float(input("T1 = "))  # 0
T2 = float(input("T2 = "))  # 90 deg
d3 = float(input("d3 = "))  # 3

# Convert Rotation angles (deg to rad)
T1 = np.radians(T1)
T2 = np.radians(T2)

# Parametric Table
PT = [[T1, np.pi/2, 0, a1],
      [T2 + np.pi/2, np.pi/2, 0, 0],
      [0, 0, 0, a2 + a3 + d3]]

# Homogeneous Transformation Matrix Formula
def compute_H_matrix(theta, alpha, a, d):
    return np.array([[np.cos(theta), -np.sin(theta) * np.cos(alpha), np.sin(theta) * np.sin(alpha), a * np.cos(theta)],
                     [np.sin(theta), np.cos(theta) * np.cos(alpha), -np.cos(theta) * np.sin(alpha), a * np.sin(theta)],
                     [0, np.sin(alpha), np.cos(alpha), d],
                     [0, 0, 0, 1]])

H0_1 = compute_H_matrix(PT[0][0], PT[0][1], PT[0][3], PT[0][2])
H1_2 = compute_H_matrix(PT[1][0], PT[1][1], PT[1][3], PT[1][2])
H2_3 = compute_H_matrix(PT[2][0], PT[2][1], PT[2][3], PT[2][2])

print("H0_1 = ")
print(np.around(H0_1, 3))
print("H1_2 = ")
print(np.around(H1_2, 3))
print("H2_3 = ")
print(np.around(H2_3, 3))

# Multiply matrices
H0_2 = np.dot(H0_1, H1_2)
H0_3 = np.dot(H0_2, H2_3)

print("Spherical Manipulator Forward Kinematics")
print("H0_3 = ")
print(np.around(H0_3, 3))

# Jacobian Matrix

# 1. Linear/Translation Vectors
Z_1 = np.array([[0], [0], [1]])  # The [0,0,1] vector

J1a = np.dot(H0_1[0:3, 0:3], Z_1)
J1b = H0_3[0:3, 3:] - H0_1[0:3, 3:]
J1 = np.cross(J1a.flatten(), J1b.flatten()).reshape(3, 1)

J2a = np.dot(H0_1[0:3, 0:3], Z_1)
J2b = H0_3[0:3, 3:] - H0_1[0:3, 3:]
J2 = np.cross(J2a.flatten(), J2b.flatten()).reshape(3, 1)

J3 = H0_2[0:3, 2:3]

# 2. Rotation/Orientation Vectors
J4 = J1a
J5 = J2a
J6 = np.array([[0], [0], [0]])

# 3. Concatenated Jacobian Matrix
JM1 = np.concatenate((J1, J2, J3), axis=1)
JM2 = np.concatenate((J4, J5, J6), axis=1)
J = np.concatenate((JM1, JM2), axis=0)

print("Jacobian Matrix J = ")
print(np.around(J, 3))

# 4. Differential Equations
d1_p, T2_p, d3_p = sp.symbols('d1_p T2_p d3_p')

q = [[d1_p], [T2_p], [d3_p]]

E = np.dot(J, q)
print("E = ")
print(E)

# Singularity
D_J = np.linalg.det(JM1)
print("Determinant of Jacobian Matrix JM1 = ", D_J)

# Inverse Velocity if not singular
if abs(D_J) > 1e-6:  # Checking for singularity
    I_V = np.linalg.inv(JM1)
    print("Inverse of Jacobian Matrix JM1 = ", I_V)
else:
    print("Jacobian Matrix JM1 is singular, inverse cannot be computed.")